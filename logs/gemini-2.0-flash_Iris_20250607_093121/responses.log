[2025-06-07 09:31:28] [Metadata: {'component': 'config'}] ```python
from ConfigSpace import ConfigurationSpace, Categorical, Float, Integer, ForbiddenAndConjunction, ForbiddenEqualsClause

def get_configspace():
    cs = ConfigurationSpace()

    # Define hyperparameters
    kernel = Categorical("kernel", ["linear", "rbf", "poly", "sigmoid"], default="rbf")
    C = Float("C", (1e-5, 10), log=True, default=1.0)
    gamma = Float("gamma", (1e-5, 10), log=True, default=0.1)
    degree = Integer("degree", (2, 5), default=3)
    coef0 = Float("coef0", (-1, 1), default=0.0)

    # Add hyperparameters to the ConfigurationSpace
    cs.add([kernel, C, gamma, degree, coef0])

    # Add forbidden clauses
    forbidden_gamma_linear = ForbiddenAndConjunction(
        ForbiddenEqualsClause(kernel, "linear"),
        ForbiddenEqualsClause(gamma, 0.1)
    )

    forbidden_degree_linear = ForbiddenAndConjunction(
        ForbiddenEqualsClause(kernel, "linear"),
        ForbiddenEqualsClause(degree, 3)
    )

    forbidden_coef0_linear = ForbiddenAndConjunction(
        ForbiddenEqualsClause(kernel, "linear"),
        ForbiddenEqualsClause(coef0, 0.0)
    )

    cs.add_forbidden_clause(forbidden_gamma_linear)
    cs.add_forbidden_clause(forbidden_degree_linear)
    cs.add_forbidden_clause(forbidden_coef0_linear)

    return cs
```
--------------------------------------------------------------------------------
[2025-06-07 09:31:28] [Metadata: {'component': 'config', 'action': 'run'}] from ConfigSpace import ConfigurationSpace, Categorical, Float, Integer, ForbiddenAndConjunction, ForbiddenEqualsClause

def get_configspace():
    cs = ConfigurationSpace()

    # Define hyperparameters
    kernel = Categorical("kernel", ["linear", "rbf", "poly", "sigmoid"], default="rbf")
    C = Float("C", (1e-5, 10), log=True, default=1.0)
    gamma = Float("gamma", (1e-5, 10), log=True, default=0.1)
    degree = Integer("degree", (2, 5), default=3)
    coef0 = Float("coef0", (-1, 1), default=0.0)

    # Add hyperparameters to the ConfigurationSpace
    cs.add([kernel, C, gamma, degree, coef0])

    # Add forbidden clauses
    forbidden_gamma_linear = ForbiddenAndConjunction(
        ForbiddenEqualsClause(kernel, "linear"),
        ForbiddenEqualsClause(gamma, 0.1)
    )

    forbidden_degree_linear = ForbiddenAndConjunction(
        ForbiddenEqualsClause(kernel, "linear"),
        ForbiddenEqualsClause(degree, 3)
    )

    forbidden_coef0_linear = ForbiddenAndConjunction(
        ForbiddenEqualsClause(kernel, "linear"),
        ForbiddenEqualsClause(coef0, 0.0)
    )

    cs.add_forbidden_clause(forbidden_gamma_linear)
    cs.add_forbidden_clause(forbidden_degree_linear)
    cs.add_forbidden_clause(forbidden_coef0_linear)

    return cs

--------------------------------------------------------------------------------
[2025-06-07 09:31:28] [Metadata: {'component': 'config', 'status': 'success'}] Configuration space generated successfully
--------------------------------------------------------------------------------
[2025-06-07 09:31:29] [Metadata: {'component': 'scenario'}] ```python
import os
from smac.scenario import Scenario
from ConfigSpace import ConfigurationSpace


def generate_scenario(cs):
    return Scenario(
        configspace=cs,
        name="smac_scenario",
        output_directory="./automl_results",
        deterministic=False,
        objectives='loss',
        n_trials=10,
        min_budget=1,
        max_budget=10,
        n_workers=2
    )
```
--------------------------------------------------------------------------------
[2025-06-07 09:31:29] [Metadata: {'component': 'scenario', 'action': 'run'}] import os
from smac.scenario import Scenario
from ConfigSpace import ConfigurationSpace


def generate_scenario(cs):
    return Scenario(
        configspace=cs,
        name="smac_scenario",
        output_directory="./automl_results",
        deterministic=False,
        objectives='loss',
        n_trials=10,
        min_budget=1,
        max_budget=10,
        n_workers=2
    )

--------------------------------------------------------------------------------
[2025-06-07 09:31:29] [Metadata: {'component': 'scenario', 'status': 'success'}] Scenario generated successfully
--------------------------------------------------------------------------------
[2025-06-07 09:31:32] [Metadata: {'component': 'train_function'}] ```python
from typing import Any
from ConfigSpace import Configuration
from sklearn.svm import SVC
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
import numpy as np


def train(cfg: Configuration, dataset: Any, seed: int) -> float:
    """
    Trains an SVM model on the provided dataset using the given configuration.

    Args:
        cfg (Configuration): The configuration object containing hyperparameters.
        dataset (Any): A dictionary containing the dataset with 'X' and 'y' keys.
        seed (int): Random seed for reproducibility.

    Returns:
        float: The average training loss (1 - accuracy) over 10 epochs.
    """
    X = dataset['X']
    y = dataset['y']

    # Infer input and output dimensions dynamically
    input_dim = X.shape[1]
    output_dim = len(np.unique(y))

    # Extract hyperparameters from the configuration
    kernel = cfg.get("kernel")
    C = cfg.get("C")
    gamma = cfg.get("gamma")
    degree = cfg.get("degree")
    coef0 = cfg.get("coef0")

    # Create the SVM model
    model = SVC(
        kernel=kernel,
        C=C,
        gamma=gamma,
        degree=degree,
        coef0=coef0,
        random_state=seed,
    )

    # Train the model for 10 epochs and compute the average loss
    epochs = 10
    total_loss = 0.0
    for _ in range(epochs):
        # Split the data into training and testing sets (80/20 split)
        X_train, X_test, y_train, y_test = train_test_split(
            X, y, test_size=0.2, random_state=seed
        )

        # Train the model
        model.fit(X_train, y_train)

        # Make predictions on the training set
        y_pred_train = model.predict(X_train)

        # Calculate the training accuracy
        accuracy = accuracy_score(y_train, y_pred_train)
        
        # Calculate the training loss (1 - accuracy)
        loss = 1.0 - accuracy

        total_loss += loss

    avg_loss = total_loss / epochs

    return avg_loss
```
--------------------------------------------------------------------------------
[2025-06-07 09:31:32] [Metadata: {'component': 'train_function', 'action': 'run'}] from typing import Any
from ConfigSpace import Configuration
from sklearn.svm import SVC
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
import numpy as np


def train(cfg: Configuration, dataset: Any, seed: int) -> float:
    """
    Trains an SVM model on the provided dataset using the given configuration.

    Args:
        cfg (Configuration): The configuration object containing hyperparameters.
        dataset (Any): A dictionary containing the dataset with 'X' and 'y' keys.
        seed (int): Random seed for reproducibility.

    Returns:
        float: The average training loss (1 - accuracy) over 10 epochs.
    """
    X = dataset['X']
    y = dataset['y']

    # Infer input and output dimensions dynamically
    input_dim = X.shape[1]
    output_dim = len(np.unique(y))

    # Extract hyperparameters from the configuration
    kernel = cfg.get("kernel")
    C = cfg.get("C")
    gamma = cfg.get("gamma")
    degree = cfg.get("degree")
    coef0 = cfg.get("coef0")

    # Create the SVM model
    model = SVC(
        kernel=kernel,
        C=C,
        gamma=gamma,
        degree=degree,
        coef0=coef0,
        random_state=seed,
    )

    # Train the model for 10 epochs and compute the average loss
    epochs = 10
    total_loss = 0.0
    for _ in range(epochs):
        # Split the data into training and testing sets (80/20 split)
        X_train, X_test, y_train, y_test = train_test_split(
            X, y, test_size=0.2, random_state=seed
        )

        # Train the model
        model.fit(X_train, y_train)

        # Make predictions on the training set
        y_pred_train = model.predict(X_train)

        # Calculate the training accuracy
        accuracy = accuracy_score(y_train, y_pred_train)
        
        # Calculate the training loss (1 - accuracy)
        loss = 1.0 - accuracy

        total_loss += loss

    avg_loss = total_loss / epochs

    return avg_loss

--------------------------------------------------------------------------------
[2025-06-07 09:31:33] [Metadata: {'component': 'train_function', 'status': 'success', 'loss': 0.6333333333333332}] Training executed successfully, loss: 0.6333333333333332
--------------------------------------------------------------------------------
